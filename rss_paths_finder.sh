#!/bin/sh

# Код требует оптимизации, а также по хорошему, сюда нужно как-то граммотно зашить файл rss_paths_finder_all.sh, объединив всё под одним скриптом, но это всё будет позже, если найду на это дело время. Так как есть подозрение, что код придётся существенно менять.

# Переменные
filebd="rss_paths_list.txt" # Путь к файлу с базой данных. Если указать только название, то он будет создан в папке рядом со скриптом.

# Вывод справочной информации. Дополню, если буду переделывать скрипт.
case "$1" in
        -h|--help)
        echo "		Справочная информация по скрипту.
	Для вызова справки открываем скрипт с ключом -h или --help.
	Если скрипт запустить без аргументов, то он сам спросит адрес файла.
	Можно и файл непосредство в скрипт для обработки отправить, для этого аргументом нужно ввести адрес файла, который желательно просканировать на суффиксы.
	Скрипт может быть выполнен в фоновом режиме, для этого достаточно открыть его с ключом -s или --silent. В таком случае название файла должно быть вторым аргументом, который следует за -s. Но пользоваться таким режимом нужно с острожностью. Например, если файл $filebd уже сущетсвует, то в него будут записываться данные прямо со следущей строки, а старые данные не будут удалены. А диалог запроса вывести не получится, так как это режим без вопросов."
        exit    ;;
        *)
        break
		;;
esac

is_silent() {
    case "$1" in
        -s|--silent)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Если файл с базой данных имеется, то вопрос что делать.
if [ -f "$filebd" ] && ! is_silent "$1" ; then
while true; do
	echo -n "Найден файл $filebd в папке рядом со скриптом. Какие действия предпринять? [del] - удалить файл и начать писать в него данные сначала. [next] или просто кнопка Enter - продолжить писать данные в файл с новой строки. [out] - выйти из скрипта. [sor] - заняться сортировкой (сортировать по алфавиту и удалить все дублируемые строки) содежимого файла $filebd.
Введите выбор: "
	read answer
	case "$answer" in
		del)
			rm -f $filebd
			echo "# Этот файл содержит список суффиксов для поиска RSS-каналов
# Строки, начинающиеся с решетки (#), являются комментариями и игнорируются
# Пустые строки тоже игнорируются
" >> $filebd
			break
			;;
		""|next)
			echo "" >> $filebd
			break
			;;
		out)
			echo "Ок, тогда пока не трогаем файл $filebd"
			exit
			;;
		sor)
			# Вроде как может привести к потере данных, так что, возможно, лучше юзать sponge, но подумаю стоит ли.
		tempfile=`mktemp ${filebd}.XXXXXX`
		awk '!/^#/ && NF' "$filebd" | sort -u > "$tempfile"
		mv "$tempfile" "$filebd"
ed -s "$filebd" <<EOF
0a
# Этот файл содержит список суффиксов для поиска RSS-каналов
# Строки, начинающиеся с решетки (#), являются комментариями и игнорируются
# Пустые строки тоже игнорируются

.
wq
EOF
			echo "Данные отсортированы, а дубли и лишняя информация удалены."
			exit
			;;
		*)
			echo "Неправильный ввод. Попробуйте еще раз."
			continue
				;;
		esac
	done
else
if ! [ -f "$filebd" ]  ; then
echo "# Этот файл содержит список суффиксов для поиска RSS-каналов
# Строки, начинающиеся с решетки (#), являются комментариями и игнорируются
# Пустые строки тоже игнорируются
" >> $filebd
fi
fi

# Получаем путь к файлу, который нужно просканировать на источники rss и сделать каталог суффиксов.
if [ $# -eq 0 ]; then
  while true; do
    read -rp "Введите путь к файлу для сканирования в нём ссылок (поддерживается файлы с разметкой xml json opml markdown и многие другие): " filescan
    # Проверка существования файла
    if [ -f "$filescan" ]; then
        break  # Прерывание цикла, если файл найден
    else
        echo "Файл '$filescan' не найден. Проверьте правильность введённого пути и попробуйте снова."
    fi
  done
else
  if  is_silent "$1" ; then
   filescan="$2"
  else
   filescan="$1"
  fi
fi

echo "" >> $filebd
echo "# Найденные вероятные суффиксы в файле $filescan. Результаты получены в $(date +"%Y-%m-%d %H:%M") скриптом $0" >> $filebd

# Тут, вероятно, можно сделать это выражение гораздо короче, но я что-то запутался. Работает, главное: извлекаем все адреса в документе (поддерживается большинство форматов, включая xml json opml markdown и так далее | убераем адреса, представляющие из себя только домен | удаляем из полученных адресов доменное имя | выводим только неповторящиеся пути после доменного имени.
# Вообще тут много разных интересностей, которые, если будет возможность, нужно будет улучшить. Так, поиск найдёт только http или https адреса, никаких sfp и так далее. Ещё он воспринимает последний слэш как разные выржаения. Так rss и rss/ будут считаться разными адресами, а потому останутся оба выражения. Я так сделал для лучшей совместимости. Так же всякие выражения на конце страницы наподобие /ru тоже будут добавлены в базу данных, хоть суффиксом и не являются. Короче, есть варинаты для оптимизаций, но действовать нужно очень аккуратно. Впрочем, я даже не уврен, что я этим скриптом какие-то ссылки не пропускаю, но вроде по идее должно по максимуму всё собирать.
grep -Eo '(http|https)://[a-zA-Z0-9./?=_%:-]*' "$filescan" | grep -vE '^(http|https)://[a-zA-Z0-9.-]+\/?$' | sed 's|^[^/]*//[^/]*/||' | sort -u  >> $filebd

if ! is_silent "$1" ; then
echo "Сканирование файла $filescan завершено. С результатми можно ознакомиться в файле $filescan."
		while true; do
			echo -n "Показать итоговые результаты успешно собранных суффиксов? [д/Н]: "
			read answer
			case "$answer" in
				Д|д|Да|да|Y|y|Yes|yes)
					tac $filebd | sed -e '/Найденные вероятные суффиксы в файле/q' | tac
					exit 0;;
				""|Н|н|Нет|нет|N|n|No|no)
					exit 0
					;;
				*)
				echo "Неправильный ввод. Попробуйте еще раз."
				continue
				;;
			esac
		done

fi